# 4장 악성 SQL 튜닝으로 초보자 탈출하기

## 4.1.1 각 테이블의 건수와 INDEX 체크.

### 각 테이블의 수 확인.

```sql
SELECT COUNT(1)
FROM 테이블명;
```


**결과 예시:**

```
COUNT(1)
---------
50000

```

### 테이블의 인덱스 체크.

```sql
SHOW INDEX FROM 테이블명;
```

**결과 예시 (가독성을 위해 `Column_name` 이후 결과 생략) :**

```
Table      Non_unique  Key_name    Seq_in_index  Column_name
---------- ----------- ----------- ------------- ------------
테이블명    0           PRIMARY     1             id
테이블명    1           idx_name    1             name
```

## 4.1.2 튜닝 방향 잡기.

각 튜닝 방향을 잡는 절차는 다음과 같다.

### 1. SQL 문 실행 결과 & 현황 파악

- `결과 및 소요 시간` 확인
- `조인/서브쿼리 구조` 확인
- `동등/범위 조건` 확인

### 2. SQL 쿼리의 구성 요소 체크

- 가시적 구성요소
    - 테이블의 데이터 건수
        - **실무 케이스**: 테이블에 1억 건의 데이터가 있을 때, 데이터를 효율적으로 처리하기 위해 데이터 파티셔닝을 적용하면 조회 성능이 크게 향상될 수 있다.
    - SELECT 절 컬럼 분석
        - **실무 케이스**: 필요한 컬럼만 SELECT 절에 명시하여 네트워크 트래픽을 줄이고, 처리 속도를 높일 수 있다.
    - 조건절 컬럼 분석
        - **실무 케이스**: WHERE 절에 사용되는 조건절 컬럼에 적절한 인덱스를 추가하여, 조회 성능을 개선할 수 있다.
    - GROUP, ORDER 컬럼 분석 (그룹, 정렬 요소 체크)
        - **실무 케이스**: GROUP BY 및 ORDER BY에 사용되는 컬럼에 대해 인덱스를 생성하면, 그룹핑 및 정렬 작업의 성능을 향상시킬 수 있다.
- 비가시적 구성요소
    - 실행 계획
        - **실무 케이스**: 실행 계획을 분석하여 불필요한 테이블 스캔이 발생하는 쿼리를 인덱스 스캔으로 변경하면, 성능이 크게 개선될 수 있다.
    - 인덱스 현황 체크
        - **실무 케이스**: 사용되지 않는 인덱스를 제거하고, 자주 사용되는 컬럼에 새로운 인덱스를 추가함으로써, 데이터베이스 성능을 최적화할 수 있다.
    - 데이터 변경 추이
        - **실무 케이스**: 데이터의 삽입, 갱신, 삭제 빈도를 분석하여, 빈번한 데이터 변경이 발생하는 테이블에 적절한 인덱스 전략을 적용할 수 있다.
    - 업무적 특징
        - **실무 케이스**: 특정 시간대에 조회가 집중되는 경우, 그 시간대에 맞춘 캐싱 전략을 도입하여 성능을 개선할 수 있다.

### 3. 튜닝 방향 판단 & 개선 적용

## 4.2 SQL 단순 수정으로 좋은 쿼리문을 만드는 예시.

- 사용하지 않는 구문이나 불필요한 구문이 있는지 확인하고  SQL 튜닝을 수행할 것.

### 예시 1. SubString 은 인덱싱을 사용할 수 없다.

사원 번호가 1100 으로 시작하면서 사원 번호가 5자리인 사원사원의 정보 모두 출력하는 쿼리.

```sql
SELECT *
FROM 사원
WHERE 
	SUBSTRING(사원번호, 1, 4) = 1100
	AND
	LENGTH(사원번호) = 5;
```

1. SQL 문 실행 결과 & 현황 파악
    
    해당 쿼리의 실행결과
    
    ```sql
    mysql> SELECT * FROM 사원 WHERE SUBSTRING(사원번호,1,4) = 1100  AND LENGTH(사원
    번호) = 5;
    +--------------+--------------+-------------+-------------+--------+--------------+
    | 사원번호     | 생년월일     | 이름        | 성          | 성별   | 입사일자     |
    +--------------+--------------+-------------+-------------+--------+--------------+
    |        11000 | 1960-09-12   | Alain       | Bonifati    | M      | 1988-08-20   |
    |        11001 | 1956-04-16   | Baziley     | Buchter     | F      | 1987-02-23   |
    |        11002 | 1952-02-26   | Bluma       | Ulupinar    | M      | 1996-12-23   |
    |        11003 | 1960-11-13   | Mariangiola | Gulla       | M      | 1987-05-24   |
    |        11004 | 1954-08-05   | JoAnna      | Decleir     | F      | 1992-01-19   |
    |        11005 | 1958-03-12   | Byong       | Douceur     | F      | 1986-07-27   |
    |        11006 | 1962-12-26   | Christoper  | Butterworth | F      | 1989-08-02   |
    |        11007 | 1962-03-16   | Olivera     | Maccarone   | M      | 1991-04-11   |
    |        11008 | 1962-07-11   | Gennady     | Menhoudj    | M      | 1988-09-18   |
    |        11009 | 1954-08-30   | Alper       | Axelband    | F      | 1986-09-09   |
    +--------------+--------------+-------------+-------------+--------+--------------+
    10 rows in set (0.16 sec)
    ```
    
    10건의 데이터를 확인할 수 있고 0.16초의 시간이 걸림을 확인할 수 있다.
    
    이제 실행 계획을 체크해보자
    
    ```sql
    mysql> EXPLAIN SELECT * FROM 사원 WHERE SUBSTRING(사원번호,1,4) = 1100  AND LENG
    TH(사원번호) = 5;
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    | id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    |  1 | SIMPLE      | 사원   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299069 |   100.00 | Using where |
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    `Type`  속성이 `ALL` 이므로 풀스캔 방식임. ← 인덱스를 사용하지 않고 바로 접근한다는 뜻이다.
    
2. SQL 쿼리의 구성 요소 체크
    
    사원 테이블에 총 몇건의 데이터가 있는지 체크한다.
    
    ```sql
    SELECT COUNT(1) FROM 사원;
    +----------+
    | COUNT(1) |
    +----------+
    |   300024 |
    +----------+
    1 row in set (0.02 sec)
    ```
    
    약 30만건의 데이터가 있음을 알 수 있다.
    
    다음으로 해당 테이블의 인덱스가 어떻게 구성되어있는지 체크한다.
    
    ```sql
     SHOW INDEX FROM 사원;
    +--------+------------+----------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table  | Non_unique | Key_name       | Seq_in_index | Column_name  | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +--------+------------+----------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | 사원   |          0 | PRIMARY        |            1 | 사원번호     | A         |      299069 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    | 사원   |          1 | I_입사일자     |            1 | 입사일자     | A         |        4365 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    | 사원   |          1 | I_성별_성      |            1 | 성별         | A         |           1 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    | 사원   |          1 | I_성별_성      |            2 | 성           | A         |        3052 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    +--------+------------+----------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    4 rows in set (0.01 sec)
    ```
    
    각 테이블의 인덱스를 보면 사원번호가 `UI`(*Unique Index*)임을 확인할 수 있다.
    
    그런데 왜 기본키로 접근하지 못하고 풀스캔을 했을까?
    
    이유인 즉슨, `SUBSTRING()` 와 `LENGTH()` 를 사용하여 사원번호 값들을 가공했기에 기본키 검색이 아니라 풀스캔을 했던 것이다.
    
3. 튜닝 방향 판단 & 개선 적용
    
    그렇다면 기본키 검색이 가능하도록 하려면 어떡할까?
    
    5자리면서 1100으로 시작하는 사원 번호를 찾는 것이므로 `BETWEEN` 구문 사용 혹은 비교 연산자를 사용하면 범위 검색이 되어 시간을 줄일 수 있을 것이다.
    
    **튜닝 후 결과**
    
    ```sql
    SELECT *
    FROM 사원
    WHERE 사원번호 BETWEEN 11000 AND 11009;
    +--------------+--------------+-------------+-------------+--------+--------------+
    | 사원번호     | 생년월일     | 이름        | 성          | 성별   | 입사일자     |
    +--------------+--------------+-------------+-------------+--------+--------------+
    |        11000 | 1960-09-12   | Alain       | Bonifati    | M      | 1988-08-20   |
    |        11001 | 1956-04-16   | Baziley     | Buchter     | F      | 1987-02-23   |
    |        11002 | 1952-02-26   | Bluma       | Ulupinar    | M      | 1996-12-23   |
    |        11003 | 1960-11-13   | Mariangiola | Gulla       | M      | 1987-05-24   |
    |        11004 | 1954-08-05   | JoAnna      | Decleir     | F      | 1992-01-19   |
    |        11005 | 1958-03-12   | Byong       | Douceur     | F      | 1986-07-27   |
    |        11006 | 1962-12-26   | Christoper  | Butterworth | F      | 1989-08-02   |
    |        11007 | 1962-03-16   | Olivera     | Maccarone   | M      | 1991-04-11   |
    |        11008 | 1962-07-11   | Gennady     | Menhoudj    | M      | 1988-09-18   |
    |        11009 | 1954-08-30   | Alper       | Axelband    | F      | 1986-09-09   |
    +--------------+--------------+-------------+-------------+--------+--------------+
    10 rows in set (0.00 sec)
    ```
    
    기존 0.16 에서 0.00sec으로 수행 시간이 줄었음을 알 수 있다.
    
    **튜닝 후 실행 계획**
    
    ```sql
    EXPLAIN
    	SELECT *
    	FROM 사원
    	WHERE 사원번호 BETWEEN 11000 AND 11009;
    +----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    | id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | 사원   | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   10 |   100.00 | Using where |
    +----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    1 row in set, 1 warning (0.00 sec)
    
    -- 기존 실행계획과 비교
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    | id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    |  1 | SIMPLE      | 사원   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299069 |   100.00 | Using where |
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    `type` 이 `range` 범위검색으로 변경됐다. 
    
    `rows` 를 보면 299069 개를 탐색하는 기존과는 다르게 10개만 탐색한 것도 확인할 수 있다.
    

### 예시 2. IFNULL 사용시에 주의할 것. 임시테이블은 비용이 든다.

사원 테이블에서 선별 기준으로 몇 명의 사원이 있는지 출력하는 쿼리.

```sql
SELECT IFNULL(성별,'NO DATA') AS 성별, COUNT(1) 건수
FROM 사원
GROUP BY IFNULL(성별, 'NO DATA');
```

1. SQL 문 실행 결과 & 현황 파악
    
    ```sql
    +--------+--------+
    | 성별   | 건수   |
    +--------+--------+
    | M      | 179973 |
    | F      | 120051 |
    +--------+--------+
    2 rows in set (0.39 sec)
    ```
    
    2개의 행이 출력되었고 총 집계 건수는 30만건, 실행 속도는 0.39sec 임을 알 수 있음.
    
    ```sql
    EXPLAIN
    SELECT IFNULL(성별,'NO DATA') AS 성별, COUNT(1) 건수
    FROM 사원
    GROUP BY IFNULL(성별, 'NO DATA');
    
    +----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
    | id | select_type | table  | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra                        |
    +----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
    |  1 | SIMPLE      | 사원   | NULL       | index | I_성별_성     | I_성별_성    | 51      | NULL | 299069 |   100.00 | Using index; Using temporary |
    +----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
    1 row in set, 1 warning (0.00 sec)
    
    ```
    
    `type` 이 `index` 이므로 인덱스 풀 스캔 방식이며 `Extra` 항목에 `Using temporary` 가 있으므로 임시 테이블을 생성한다는 걸 알 수 있음.
    
    > 왜 임시 테이블이 생성될까?
    > 
    > 
    > IFNULL() 값의 여부를 검사하기 위해서 임시테이블이 생성된다.
    > 
2. SQL 쿼리의 구성 요소 체크
    
    ```sql
    desc 사원;
    
    +--------------+---------------+------+-----+---------+-------+
    | Field        | Type          | Null | Key | Default | Extra |
    +--------------+---------------+------+-----+---------+-------+
    | 사원번호     | int           | NO   | PRI | NULL    |       |
    | 생년월일     | date          | NO   |     | NULL    |       |
    | 이름         | varchar(14)   | NO   |     | NULL    |       |
    | 성           | varchar(16)   | NO   |     | NULL    |       |
    | 성별         | enum('M','F') | NO   | MUL | NULL    |       |
    | 입사일자     | date          | NO   | MUL | NULL    |       |
    +--------------+---------------+------+-----+---------+-------+
    6 rows in set (0.00 sec)
    ```
    
    성별의 경우 NOT NULL 속성이 적용됨을 알 수 있음. 그러므로 IFNULL 사용할 필요가 없음. 
    
3. 튜닝 방향 판단 & 개선 적용 
    
    ```sql
    EXPLAIN
    SELECT 성별, COUNT(1) 건수
    FROM 사원
    GROUP BY 성별;
    
    +--------+--------+
    | 성별   | 건수   |
    +--------+--------+
    | M      | 179973 |
    | F      | 120051 |
    +--------+--------+
    2 rows in set (0.08 sec)
    ```
    
    0.39sec → 0.08 sec
    
    ```sql
    mysql> EXPLAIN
        -> SELECT 성별, COUNT(1) 건수
        -> FROM 사원
        -> GROUP BY 성별;
        
    +----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+-------------+
    | id | select_type | table  | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+-------------+
    |  1 | SIMPLE      | 사원   | NULL       | index | I_성별_성     | I_성별_성    | 51      | NULL | 299069 |   100.00 | Using index |
    +----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+-------------+
    1 row in set, 1 warning (0.00 sec)
    
    -- 개선 전.
    +----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
    | id | select_type | table  | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra                        |
    +----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
    |  1 | SIMPLE      | 사원   | NULL       | index | I_성별_성     | I_성별_성    | 51      | NULL | 299069 |   100.00 | Using index; Using temporary |
    +----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    임시 테이블을 사용하지 않는 것으로도 실행 속도를 줄 일 수 있다.
    

### 예시 3. 형변환할 시에는 인덱스를 활용할 수 없다.

급여 테이블에서 현재 유효한 급여 정보만 조회하고자 하는 경우.

1. SQL 문 실행 결과 & 현황 파악
    
    ```sql
    SELECT COUNT(1)
    FROM 급여
    WHERE 사용여부 = 1;
    
    +----------+
    | COUNT(1) |
    +----------+
    |    42842 |
    +----------+
    1 row in set (0.42 sec)
    ```
    
    약 4만건의 데이터, 0.42 sec 실행속도.
    
    ```sql
    -- 실행 계획
    EXPLAIN
    SELECT COUNT(1)
    FROM 급여
    WHERE 사용여부 = 1;
    
    +----+-------------+--------+------------+-------+----------------+----------------+---------+------+---------+----------+--------------------------+
    | id | select_type | table  | partitions | type  | possible_keys  | key            | key_len | ref  | rows    | filtered | Extra                    |
    +----+-------------+--------+------------+-------+----------------+----------------+---------+------+---------+----------+--------------------------+
    |  1 | SIMPLE      | 급여   | NULL       | index | I_사용여부     | I_사용여부     | 4       | NULL | 2838398 |    10.00 | Using where; Using index |
    +----+-------------+--------+------------+-------+----------------+----------------+---------+------+---------+----------+--------------------------+
    1 row in set, 3 warnings (0.01 sec)
    ```
    
    `type`을 보면 `index` 스캔을 사용했음을 알 수 있음. 
    
    `rows` 와 `filtered` 를 보면 약 28만건의 데이터를 탐색하여 10% 의 데이터를 필터링하여 최종 데이터값을 산출했음을 알 수 있다
    
2. SQL 쿼리의 구성 요소 체크
    
    먼저 다음과 같은 SQL문을 실행하여 조건절로 작성된 사용 여부 열의 데이터 건수 확인.
    
    ```sql
    SELECT 사용여부, COUNT(1)
    FROM 급여
    GROUP BY 사용여부;
    
    +--------------+----------+
    | 사용여부     | COUNT(1) |
    +--------------+----------+
    | 0            |  2801205 |
    | 1            |    42842 |
    +--------------+----------+
    2 rows in set (0.38 sec)
    ```
    
    → 조회하고자 하는 쿼리에 사용된 사용 여부 열의 값이 1 인 데이터 건수는 10% 이하임을 알 수 있음.
    
    급여 테이블에 인덱스 현황 확인.
    
    ```sql
    SHOW INDEX FROM 급여;
    
    +--------+------------+----------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table  | Non_unique | Key_name       | Seq_in_index | Column_name  | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +--------+------------+----------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | 급여   |          0 | PRIMARY        |            1 | 사원번호     | A         |      302984 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    | 급여   |          0 | PRIMARY        |            2 | 시작일자     | A         |     2838398 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    | 급여   |          1 | I_사용여부     |            1 | 사용여부     | A         |           1 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
    +--------+------------+----------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    3 rows in set (0.01 sec)
    ```
    
    I_사용여부 인덱스가 있어 해당 인덱스 스캔만 사용하면 되나 인덱스 풀 스캔을 사용하고 있다는 것을 알 수 있음.
    
    왜 인덱스 풀 스캔이 발생하는지 해당 명령어로 체크
    
    ```sql
    desc 급여;
    
    +--------------+---------+------+-----+---------+-------+
    | Field        | Type    | Null | Key | Default | Extra |
    +--------------+---------+------+-----+---------+-------+
    | 사원번호     | int     | NO   | PRI | NULL    |       |
    | 연봉         | int     | NO   |     | NULL    |       |
    | 시작일자     | date    | NO   | PRI | NULL    |       |
    | 종료일자     | date    | NO   |     | NULL    |       |
    | 사용여부     | char(1) | YES  | MUL |         |       |
    +--------------+---------+------+-----+---------+-------+
    5 rows in set (0.00 sec)
    ```
    
    사용 여부가 `char(1)` 으로 문자형 데이터 유형이지만 해당 쿼리는 `WHERE 사원번호 = 1` 로 조회하기에 DBMS 내부에 **`묵시적 형 변환`**이 발생하였던 것이었음.
    
3. 튜닝 방향 판단 & 개선 적용 
    
    ```sql
    SELECT COUNT(1)
    FROM 급여
    WHERE 사용여부 = '1';
    
    +----------+
    | COUNT(1) |
    +----------+
    |    42842 |
    +----------+
    1 row in set (0.02 sec)
    ```
    
    묵시적 형 변환을 제거하여 I_사용여부 인덱스를 사용하게만듦. 실행 시간 0.42 sec → 0.02 sec
    
    **실행 계획 확인**
    
    ```sql
    EXPLAIN
    SELECT COUNT(1)
    FROM 급여
    WHERE 사용여부 = '1';
    
    -- 개선 후
    +----+-------------+--------+------------+------+----------------+----------------+---------+-------+-------+----------+-------------+
    | id | select_type | table  | partitions | type | possible_keys  | key            | key_len | ref   | rows  | filtered | Extra       |
    +----+-------------+--------+------------+------+----------------+----------------+---------+-------+-------+----------+-------------+
    |  1 | SIMPLE      | 급여   | NULL       | ref  | I_사용여부     | I_사용여부     | 4       | const | 82824 |   100.00 | Using index |
    +----+-------------+--------+------------+------+----------------+----------------+---------+-------+-------+----------+-------------+
    1 row in set, 1 warning (0.00 sec)
    
    -- 개선 전.
    +----+-------------+--------+------------+-------+----------------+----------------+---------+------+---------+----------+--------------------------+
    | id | select_type | table  | partitions | type  | possible_keys  | key            | key_len | ref  | rows    | filtered | Extra                    |
    +----+-------------+--------+------------+-------+----------------+----------------+---------+------+---------+----------+--------------------------+
    |  1 | SIMPLE      | 급여   | NULL       | index | I_사용여부     | I_사용여부     | 4       | NULL | 2838398 |    10.00 | Using where; Using index |
    +----+-------------+--------+------------+-------+----------------+----------------+---------+------+---------+----------+--------------------------+
    1 row in set, 3 warnings (0.01 sec)
    ```
    
    개선 후 실행 계획을 보면  `type` 이 `index`(인덱스 풀 스캔) → `ref` (하나의 인덱스를 활용하여 1대 다 검색) 으로 바뀐 것을 확인할 수 있다.
    
    > **데이터 유형의 중요성**
    > 
    > 
    > 데이터 유형에 맞게 열을 활용해야 내부적 형 변환이 발생하지 않는다!
    > 
    > 내부적 형 변환이 발생할 경우 기껏 만들어놓은 인덱스를 활용하지 못하는 경우가 있으므로 주의!
    > 

### 예시 4. 열을 결합할 경우

사원 테이블에서 성별의 값과 1칸의 공백. 성의 값을 모두 결합한 결과가 ‘***M Radwan***’ 인경우를 검색하는 쿼리

```sql
SELECT *
FROM 사원
WHERE CONCAT(성별, ' ', 성) = 'M Radwan';
```

1. SQL 문 실행 결과 & 현황 파악
    
    ```sql
    +--------------+--------------+-------------+--------+--------+--------------+
    | 사원번호     | 생년월일     | 이름        | 성     | 성별   | 입사일자     |
    +--------------+--------------+-------------+--------+--------+--------------+
    |        10346 | 1963-01-29   | Aamod       | Radwan | M      | 1987-01-27   |
    |        16491 | 1952-12-03   | Emdad       | Radwan | M      | 1988-05-28   |
    |        18169 | 1954-09-21   | Nathalie    | Radwan | M      | 1998-03-04   |
    ... 이하 생략.
    |       491504 | 1954-12-27   | Zeydy       | Radwan | M      | 1998-03-08   |
    |       498822 | 1955-06-15   | Boutros     | Radwan | M      | 1989-06-13   |
    +--------------+--------------+-------------+--------+--------+--------------+
    102 rows in set (0.13 sec)
    ```
    
    102 건의 행이 검색되었고 수행 시간은 0.13 sec
    
    **실행 계획 확인**
    
    ```sql
    EXPLAIN
    SELECT *
    FROM 사원
    WHERE CONCAT(성별, ' ', 성) = 'M Radwan';
    
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    | id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    |  1 | SIMPLE      | 사원   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299069 |   100.00 | Using where |
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    `type` 이 `ALL` 임, `Extra` 가 `Using where`→ WHERE 문에 따른 풀스캔이 실행되었음.
    
2. SQL 쿼리의 구성 요소 체크
    
    **조회하려는 전체 데이터 건수 체크**
    
    ```sql
    SELECT '성별_성', COUNT(1)
    FROM 사원
    WHERE CONCAT(성별, ' ', 성) = 'M Radwan'
    
    UNION ALL 
    
    SELECT '전체 데이터', COUNT(1)
    FROM 사원;
    
    +------------------+----------+
    | 성별_성          | COUNT(1) |
    +------------------+----------+
    | 성별_성          |      102 |
    | 전체 데이터      |   300024 |
    +------------------+----------+
    2 rows in set (0.10 sec)
    ```
    
    30만건의 데이터 중 102 건의 데이터를 조회하려고 함을 알 수 있음.
    
    ```sql
    desc 사원;
    
    +--------------+---------------+------+-----+---------+-------+
    | Field        | Type          | Null | Key | Default | Extra |
    +--------------+---------------+------+-----+---------+-------+
    | 사원번호     | int           | NO   | PRI | NULL    |       |
    | 생년월일     | date          | NO   |     | NULL    |       |
    | 이름         | varchar(14)   | NO   |     | NULL    |       |
    | 성           | varchar(16)   | NO   |     | NULL    |       |
    | 성별         | enum('M','F') | NO   | MUL | NULL    |       |
    | 입사일자     | date          | NO   | MUL | NULL    |       |
    +--------------+---------------+------+-----+---------+-------+
    6 rows in set (0.00 sec)
    
    SHOW INDEX FROM 사원;
    
    +--------+------------+----------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | Table  | Non_unique | Key_name       | Seq_in_index | Column_name  | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
    +--------+------------+----------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    | 사원   |          0 | PRIMARY        |            1 | 사원번호     | A         |      299069 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    | 사원   |          1 | I_입사일자     |            1 | 입사일자     | A         |        4365 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    | 사원   |          1 | I_성별_성      |            1 | 성별         | A         |           1 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    | 사원   |          1 | I_성별_성      |            2 | 성           | A         |        3052 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
    +--------+------------+----------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
    4 rows in set (0.00 sec)
    ```
    
    사원 테이블의 인덱스가 `I_성별_성` 인덱스가 존재함을 알 수 있음
    
    따라서 WHERE 절의 조건과 부합함을 알 수 있고 조건문도 동등조건이므로 인덱스를 활용하여 데이터를 빠르게 조회 가능
    
3. 튜닝 방향 판단 & 개선 적용 
    
    **개선 쿼리 실행 결과**
    
    ```sql
    SELECT *
    FROM 사원
    WHERE 성별 = 'M'
    	AND
    	성 = 'Radwan';
    	
    +--------------+--------------+-------------+--------+--------+--------------+
    | 사원번호     | 생년월일     | 이름        | 성     | 성별   | 입사일자     |
    +--------------+--------------+-------------+--------+--------+--------------+
    |        10346 | 1963-01-29   | Aamod       | Radwan | M      | 1987-01-27   |
    |        16491 | 1952-12-03   | Emdad       | Radwan | M      | 1988-05-28   |
    |        18169 | 1954-09-21   | Nathalie    | Radwan | M      | 1998-03-04   |
    ... 이하 생략.
    |       491504 | 1954-12-27   | Zeydy       | Radwan | M      | 1998-03-08   |
    |       498822 | 1955-06-15   | Boutros     | Radwan | M      | 1989-06-13   |
    +--------------+--------------+-------------+--------+--------+--------------+
    102 rows in set (0.00 sec)
    ```
    
    실행 시간이 0.13 sec → 0.00sec 으로 줄어듦
    
    ```sql
    EXPLAIN
    SELECT *
    FROM 사원
    WHERE 성별 = 'M'
    	AND
    	성 = 'Radwan';
    	
    +----+-------------+--------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
    | id | select_type | table  | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra |
    +----+-------------+--------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
    |  1 | SIMPLE      | 사원   | NULL       | ref  | I_성별_성     | I_성별_성    | 51      | const,const |  102 |   100.00 | NULL  |
    +----+-------------+--------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
    1 row in set, 1 warning (0.00 sec)
    -- 개선 전
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    | id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    |  1 | SIMPLE      | 사원   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299069 |   100.00 | Using where |
    +----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    `type` 이 `ref` 로 I_성별_성 인덱스를 사용해서 사원 테이블에 접근함을 알 수 있음.
    
    그 결과 30만건의 데이터에 접근해야 했던 쿼리가 102건의 데이터만 조회하면 되도록 개선됨.